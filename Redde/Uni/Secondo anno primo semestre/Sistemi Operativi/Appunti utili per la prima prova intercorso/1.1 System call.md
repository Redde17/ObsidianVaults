Quando l'utente chiede al SO di voler effetture un servizio, questo viene realizzato attraverso le system call. Tipicamente le system call sono delle interfacce che il SO mette a disposizione del programmatore in maniera tale che una qualsiasi richiesta venga fatta al sistema operativo, viene gestita mediante system call.
Usando le system call, si usano delle funzioni di libreria (API) che sono piú facili da gestire poiché nascondono dettagli implementativi che le system call utilizzanno effettivamente dietro a chiamate di funzione.

Immaginiamo di avere questa porzione di codice, e ad un certo punto viene invocata la printf. Quando viene invocata la printf, il SO va a prendere l’effettivo codice della printf scritto da qualche parte, lo porta in memoria principale e inizia ad interpretarlo. Ad un certo punto, nel codice della printf appare la funzione write(), che è una system call, e di conseguenza si passa in kernel mode e ciò permetterà di stampare a schermo l’informazione che l’utente richiede. La write() ha esattamente l’aspetto di una normale funzione C, solo che essendo una system call non esiste una porzione di codice che implementa tale funzione, infatti le system call sono qualcosa di fisico che il kernel utilizza per poter realizzare quello che è stato chiesto

Poiché non esiste una porzione di codice che implementa le system call il SO associa ad ogni system call un numeretto. 
Ogni qualvolta si chiede al SO di mandare una system call, nell’esempio la funzione open() e per esempio sa che la funzione ha numero 10, nel kernel del SO c’è una sorta di tabella al cui interno ci sono i numeri contenenti ciascuna system call, per cui va nell’entry 10 ed è presente un link ad una sequenza di istruzioni che devono eseguite per l’implementazione della system call open(). Di conseguenza noi non avremo mai a disposizione l’implementazione della system call open, ma sappiamo naturalmente ciò che fa

