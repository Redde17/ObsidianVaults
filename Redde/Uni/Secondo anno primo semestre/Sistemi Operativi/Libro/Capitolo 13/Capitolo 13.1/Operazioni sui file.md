Un file è un tipo di dato astratto. Per definire adeguatamente un file è necessario considerare le operazioni che si possono eseguire su di esso. Il sistema operativo può offrire chiamate di sistema per creare, scrivere, leggere, spostare, cancellare e troncare un file. Esaminiamo ciò che deve fare un sistema operativo per ciascuna di queste sei operazioni di base. 
Ciò dovrebbero aiutare a vedere come si possano realizzare altre operazioni simili, per esempio la ridenominazione di un file.
-   Creazione di un file. 
	Per creare un file è necessario compiere due passaggi. In primo luogo si deve trovare lo spazio per il file nel file system. Inoltre, per il file si deve creare un nuovo elemento nella directory.
    
-   Scrittura di un file. 
	Per scrivere in un file viene effettuata una chiamata di sistema che specifica il nome del file e le informazioni che si vogliono scrivere. 
	Dato il nome del file, il sistema ricerca la directory per individuare la posizione del file. Il file system deve mantenere un _puntatore di scrittura_ alla locazione nel file in cui deve avvenire l’operazione di scrittura successiva. Il puntatore si deve aggiornare ogniqualvolta si esegue una scrittura.
    
-   Lettura di un file. 
	Per leggere da un file è necessaria una chiamata di sistema che specifichi il nome del file e la posizione in memoria dove collocare il blocco del file da leggere. Anche in questo caso si cerca l’elemento corrispondente nella directory e il sistema deve mantenere un _puntatore di lettura_ alla locazione nel file in cui deve avvenire la successiva operazione di lettura. Una volta completata la lettura, si aggiorna il puntatore. Di solito un processo o legge o scrive in un file, e la posizione corrente è mantenuta come un puntatore alla posizione corrente del file specifico del processo. Sia le operazioni di lettura sia quelle di scrittura adoperano lo stesso puntatore, risparmiando spazio e riducendo la complessità del sistema.
    
-   Riposizionamento in un file. 
	Si ricerca l’elemento appropriato nella directory e si assegna un nuovo valore al puntatore alla posizione corrente nel file. Il riposizionamento non richiede alcuna operazione di i/o. Questa operazione è anche nota come _posizionamento_ o _ricerca_ (seek) nel file.
    
-   Cancellazione di un file. 
	Per cancellare un file si cerca l’elemento della directory associato al file designato, si rilascia lo spazio associato al file (in modo che possa essere adoperato per altri) e si elimina l’elemento della directory.
    
-   Troncamento di un file. 
	Si potrebbe voler cancellare il contenuto di un file, ma mantenere i suoi attributi. Invece di forzare gli utenti a cancellare il file e quindi ricrearlo, questa funzione consente di mantenere immutati gli attributi (a esclusione della lunghezza del file) pur azzerando la lunghezza del file e rilasciando lo spazio occupato.

Queste sei operazioni di base comprendono l’insieme minimo delle operazioni richieste per i file.
Altre operazioni comuni comprendono l’_aggiunta_ (appending) di nuove informazioni alla fine di un file esistente e la _ridenominazione_ di un file esistente. Queste operazioni primitive si possono combinare per compiere altre operazioni. Per esempio, per creare una _copia_ di un file, o per copiare il file in un altro dispositivo di i/o, come una stampante o un video, è sufficiente creare un nuovo file, leggere i dati dal file vecchio e scriverli nel nuovo. 
Sono inoltre necessarie operazioni che consentano a un utente di leggere e impostare i vari attributi di un file. Per esempio, si potrebbe volere un’operazione che consenta all’utente di determinare lo stato di un file, come la lunghezza, e che consenta di definire gli attributi di un file, come il proprietario.

La maggior parte delle operazioni sopra citate richiede una ricerca nella directory dell’elemento associato al file specificato. Per evitare questa continua ricerca, molti sistemi richiedono l’impiego di una chiamata di sistema open() prima che un file venga utilizzato. Il sistema operativo mantiene una tabella contenente informazioni riguardanti tutti i file aperti (detta, per l’appunto, tabella dei file aperti). Quando si richiede un’operazione su un file, questo viene individuato tramite un indice in tale tabella, in questo modo si evita qualsiasi ricerca. Quando il file non è più attivamente usato viene _chiuso_ dal processo, e il sistema operativo rimuove l’elemento a esso associato dalla tabella dei file aperti. Le chiamate di sistema che lavorano su file chiusi invece che aperti sono create() e delete().

Alcuni sistemi aprono implicitamente un file al primo riferimento e lo chiudono automaticamente quando il processo che lo ha aperto termina. La maggior parte dei sistemi invece esige che il programmatore richieda l’apertura del file in modo esplicito per mezzo di una chiamata di sistema open() prima che sia possibile adoperarlo. L’operazione open() riceve il nome del file, lo cerca nella directory e copia l’elemento della directory a esso associato nella tabella dei file aperti. La chiamata di sistema open() può accettare anche informazioni sui modi d’accesso: creazione, sola lettura, lettura e scrittura, sola aggiunta, ecc. Si controllano i permessi relativi al file, e se la modalità d’accesso richiesta è consentita, si apre il file per il processo. La chiamata di sistema open() riporta di solito un puntatore all’elemento nella tabella dei file aperti; questo puntatore si adopera al posto dell’effettivo nome del file in tutte le operazioni di i/o, evitando così successive operazioni di ricerca e semplificando l’interfaccia delle chiamate di sistema.

La realizzazione delle operazioni open() e close() è più complicata in un ambiente multiutente dove più processi possono aprire un file contemporaneamente. Di solito il sistema operativo introduce due livelli di tabelle interne: una tabella per ciascun processo e una tabella di sistema. La tabella del processo contiene i riferimenti a tutti i file aperti da quel processo. In questa tabella sono memorizzate le informazioni sull’uso del file da parte del processo; per esempio, si trovano in questa tabella il puntatore alla posizione corrente per ciascun file e le informazioni sui diritti d’accesso ai file.

Ciascun elemento della tabella associata a ciascun processo punta a sua volta a una tabella di sistema dei file aperti, contenente le informazioni indipendenti dai processi come la posizione dei file nei dischi, le date degli accessi e le dimensioni dei file. Quando un file è stato aperto da un processo, la tabella dei file aperti del sistema contiene un elemento relativo al file; una open() eseguita da un altro processo comporta solamente l’aggiunta di un nuovo elemento nella tabella dei file aperti associata al processo, che punta al corrispondente elemento della tabella di sistema. In genere, la tabella dei file aperti ha anche un _contatore delle aperture_ associato a ciascun file, indicante il numero di processi che hanno aperto quel file. Ogni close() decrementa questo _contatore_; quando raggiunge il valore zero il file non è più in uso e si elimina l’elemento corrispondente dalla tabella dei file aperti.

Riassumendo, a ciascun file aperto sono associate le diverse seguenti informazioni.

-   Puntatore al file. 
	Nei sistemi che non prevedono un offset come parametro delle chiamate di sistema read() e write(), il sistema deve tener traccia dell’ultima posizione di lettura e scrittura sotto forma di un puntatore alla posizione corrente nel file. Questo puntatore è unico per ogni processo che opera sul file e quindi deve essere tenuto separato dagli attributi del file residenti nel disco.
    
-   Contatore dei file aperti. 
	Man mano che si chiudono i file, per evitare di esaurire lo spazio associato alla propria tabella dei file aperti, il sistema operativo deve riutilizzarne gli elementi. Poiché più processi possono aprire uno stesso file, prima di rimuovere l’elemento corrispondente, il sistema deve attendere l’ultima chiusura del file. Questo contatore tiene traccia del numero di open() e close(), e raggiunge il valore zero dopo l’ultima chiusura, momento in cui il sistema può rimuovere l’elemento della tabella.
    
-   Posizione nel disco del file. 
	La maggior parte delle operazioni richiede al sistema di modificare i dati contenuti nel file. L’informazione necessaria per localizzare il file (ovunque si trovi, sia esso su una memoria di massa, su un file server in rete, o su un’unità ram) è mantenuta in memoria, per evitare di doverla prelevare dal disco a ogni operazione.
    
-   Diritti d’accesso. 
	Ciascun processo apre un file in una delle modalità d’accesso. Questa informazione è contenuta nella tabella del processo in modo che il sistema operativo possa permettere o negare le successive richieste di i/o.

Alcuni sistemi operativi offrono la possibilità di applicare lock a un file aperto (o a parti di esso). Quando un processo intende proteggere un file dall’accesso concorrente di altri processi, si serve dei lock. L’utilità dei lock dei file emerge nel caso di file condivisi da diversi processi: un file di log, per esempio, può subire modifiche da parte di molti processi nel sistema.

I lock dei file sono basati su una funzionalità simile ai lock di lettura-scrittura (Paragrafo 7.1.2). Un lock condiviso è assimilabile, per funzionamento, ai lock di lettura: entrambi consentono a più processi concorrenti di appropriarsene. Un lock esclusivo mostra invece analogie con i lock di scrittura, perché un solo processo per volta può acquisire questo tipo di lock. Si noti bene che non in tutti i sistemi operativi forniscono entrambi i tipi di lock; alcuni sistemi forniscono solamente lock esclusivi dei file.

Inoltre, il sistema operativo può fornire meccanismi di lock dei file obbligatori (_mandatory_), oppure consultivi (_advisory_). Se un lock è obbligatorio, il sistema operativo impedirà a qualunque altro processo di accedere al file interessato una volta che il suo lock sia stato acquisito. Poniamo, per esempio, che un processo acquisisca un lock esclusivo del file system.log. Se un altro processo – per esempio, un editor – tentasse di aprire system.log, il sistema operativo negherebbe l’accesso finché il lock esclusivo ritorni disponibile. Ciò accade anche se l’editor non è esplicitamente programmato per acquisire il lock. Qualora invece il lock è consultivo, il sistema operativo non impedirà l’accesso dell’editor a system.log. Tuttavia, per poter accedere al file, l’editor deve essere scritto in modo tale da acquisire esplicitamente il lock. In altri termini, se il lock è obbligatorio, il sistema operativo assicura l’integrità dei dati soggetti a lock; se il lock è consultivo, è compito dei programmatori garantire la corretta acquisizione e cessione dei lock. In linea generale, i sistemi operativi Windows adottano i lock obbligatori, mentre i sistemi unix impiegano i lock consultivi.

L’uso dei lock dei file richiede l’osservazione delle stesse accortezze della sincronizzazione dei processi. Per esempio, i programmatori impegnati a sviluppare su sistemi con lock obbligatori devono prestare attenzione a detenere i lock esclusivi solo per l’effettiva durata degli accessi ai file; in caso contrario, bloccheranno anche gli accessi da parte di altri processi. Occorre, inoltre, attuare misure appropriate al fine di evitare che due o più processi entrino in stallo nel tentativo di acquisire i lock per i file.