Si considerino due programmatori che lavorano a un progetto comune. I file associati a quel progetto si possono memorizzare in una sottodirectory, separandoli da altri progetti e file dei due programmatori, ma poiché entrambi i programmatori hanno le stesse responsabilità sul progetto, ciascuno vuole che la sottodirectory si trovi nelle proprie directory. In questa situazione la sottodirectory comune deve essere _condivisa_. Nel sistema esiste quindi una directory o un file condivisi, in due, o più, posizioni contemporaneamente.

La struttura ad albero non ammette la condivisione di file o directory. Un grafo aciclico (cioè senza cicli) permette alle directory di avere sottodirectory e file condivisi. Lo stesso file o la stessa sottodirectory possono essere in due directory diverse. Un grafo aciclico rappresenta la generalizzazione naturale dello schema delle directory con struttura ad albero.
![[Pasted image 20221219154255.png]]

Il fatto che un file sia condiviso, o che lo sia una directory, è diverso dall’avere due copie del file: con due copie ciascun programmatore potrebbe vedere la copia presente nella propria directory e non l’originale; se un programmatore modifica il file, le modifiche non appaiono nell’altra copia. Se invece il file è condiviso esiste _un_ solo file effettivo, perciò tutte le modifiche sono immediatamente visibili. La condivisione è di particolare importanza se applicata alle sottodirectory; un nuovo file creato da un utente appare automaticamente in tutte le sottodirectory condivise.

Quando più persone lavorano insieme, tutti i file da condividere si possono inserire in una directory comune. La directory utente di ogni membro del gruppo contiene questa directory di file condivisi in forma di sottodirectory. Anche nel caso di un singolo utente, l’organizzazione dei file di tale utente può richiedere che alcuni file siano inseriti in più sottodirectory. Per esempio, un programma scritto per un progetto particolare deve trovarsi sia nella directory di tutti i programmi sia nella directory di quel progetto.

I file e le sottodirectory condivisi si possono realizzare in molti modi. Un metodo diffuso, esemplificato da molti tra i sistemi unix, prevede la creazione di un nuovo elemento di directory, chiamato collegamento. Un collegamento (_link_) è un puntatore a un altro file o un’altra directory. Per esempio, un collegamento si può realizzare come un nome di percorso assoluto o relativo. Quando si fa riferimento a un file, si compie una ricerca nella directory. Se l’elemento cercato è contrassegnato come collegamento, riporta il nome di percorso del file reale. Quindi si _risolve_ il collegamento usando il nome di percorso per localizzare il file reale. I collegamenti si identificano facilmente tramite il loro formato nell’elemento della directory (o, nei sistemi che gestiscono i tipi, dal tipo speciale), e sono in pratica puntatori indiretti. Durante l’attraversamento degli alberi delle directory il sistema operativo ignora questi collegamenti, preservando così la struttura aciclica.

Un altro comune metodo per la realizzazione dei file condivisi prevede semplicemente la duplicazione di tutte le informazioni relative ai file in entrambe le directory che lo condividono: i due elementi delle directory sono identici. Si consideri la differenza fra i due approcci. Un collegamento è chiaramente diverso dall’elemento originale della directory. Duplicando gli elementi della directory, invece, la copia e l’originale sono resi indistinguibili: sorge allora il problema di mantenere la coerenza se il file viene modificato.

Una struttura di directory a grafo aciclico è più flessibile di una semplice struttura ad albero, ma anche più complessa. Si devono prendere in considerazione parecchi problemi. Un file può avere più nomi di percorso assoluti, quindi nomi diversi possono riferirsi allo stesso file. Questa situazione è simile al problema degli _alias_ nei linguaggi di programmazione. Quando si percorre tutto il file system – per trovare un file, per raccogliere dati statistici su tutti i file o per fare le copie di backup dei file – il problema diviene importante poiché le strutture condivise non si devono attraversare più di una volta.

Un altro problema riguarda la cancellazione, poiché è necessario stabilire in quali casi è possibile allocare e riutilizzare lo spazio allocato a un file condiviso. Una possibilità prevede che a ogni operazione di cancellazione segua l’immediata rimozione del file; quest’azione può però lasciare puntatori sospesi (_dangling_) a un file che ormai non esiste più. Problema ancora più grave, se i puntatori contengono indirizzi effettivi del disco e lo spazio viene poi riutilizzato per altri file, i puntatori potrebbero puntare nel mezzo di questi altri file.

In un sistema dove la condivisione è realizzata da collegamenti simbolici la gestione di questa situazione è relativamente semplice. La cancellazione di un collegamento non influisce sul file originale, poiché si rimuove solo il collegamento. Se si cancella il file, si libera lo spazio corrispondente lasciando in sospeso il collegamento; è possibile ricercare tutti questi collegamenti e rimuoverli, ma se in ogni file non esiste una lista dei collegamenti associati al file stesso questa ricerca può essere abbastanza onerosa. In alternativa, si possono lasciare i collegamenti finché non si tenta di usarli, quindi si scopre che il file con il nome dato dal collegamento non esiste e non si riesce a risolvere il collegamento; l’accesso è trattato proprio come qualsiasi altro nome di file errato. In questo caso, il progettista del sistema deve decidere attentamente cosa si debba fare quando si cancella un file e si crea un altro file con lo stesso nome, prima che sia stato usato un collegamento simbolico al file originario. In unix, quando si cancella un file, i collegamenti simbolici restano, è l’utente che deve rendersi conto che il file originale è scomparso o è stato sostituito. Nella famiglia di sistemi operativi Microsoft Windows si segue lo stesso criterio.

Un altro tipo di approccio alla cancellazione prevede la conservazione del file finché non siano stati cancellati tutti i riferimenti a esso. In questo caso è necessario disporre di un meccanismo che permetta di determinare che l’ultimo riferimento a quel file è stato cancellato; è possibile tenere una lista di tutti i riferimenti a un file (elementi di directory o collegamenti simbolici). Quando si crea un collegamento, oppure una copia dell’elemento della directory, si aggiunge un nuovo elemento alla lista dei riferimenti al file; quando si cancella un collegamento oppure un elemento della directory, si elimina dalla lista l’elemento corrispondente. Quando la sua lista di riferimenti è vuota, il file viene cancellato.

Questo metodo presenta, però, un problema: la dimensione della lista dei riferimenti al file può essere variabile e potenzialmente grande.
Tuttavia, non è realmente necessario mantenere l’intera lista, è sufficiente un contatore del numero di riferimenti. Un nuovo collegamento o un nuovo elemento della directory incrementa il numero dei riferimenti; la cancellazione di un collegamento o di un elemento decrementa questo numero