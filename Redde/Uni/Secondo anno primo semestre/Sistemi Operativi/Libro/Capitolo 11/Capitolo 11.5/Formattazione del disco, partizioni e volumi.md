Un dispositivo di storage nuovo è _tabula rasa_: è semplicemente un piatto ricoperto di materiale magnetico o un insieme di celle di memorizzazione a semiconduttore non inizializzate; prima che possa memorizzare dati, deve essere diviso in settori che possano essere letti o scritti dal controllore. Nel caso dei dispositivi nvm, devono essere inizializzate le pagine e creata la ftl.
Questo processo si chiama formattazione di basso livello, o formattazione fisica.
La formattazione di basso livello riempie il dispositivo con una speciale struttura dati per ogni locazione di memorizzazione.
La struttura dati per un settore o una pagina tipicamente consiste di un’intestazione, un’area per i dati e una coda. 
L’intestazione e la coda contengono informazioni usate dal controllore del disco, per esempio il numero del settore e un codice per la correzione degli errori (_error-correcting code_, ecc).

La formattazione fisica dei dispositivi è eseguita nella maggior parte dei casi dal costruttore come parte del processo produttivo; ciò permette al costruttore di provare il dispositivo, e di inizializzare la corrispondenza fra blocchi logici e settori o pagine correttamente funzionanti. La scelta della dimensione del settore è di solito ristretta a poche opzioni, come 512 byte o 4 kb. La formattazione in settori più grandi implica la presenza di meno settori su ogni traccia, ma anche meno intestazioni e code, e quindi maggior spazio per i dati utente. Alcuni sistemi operativi gestiscono solo una specifica dimensione dei settori.

Prima di usare un dispositivo come contenitore di file, il sistema operativo deve ancora registrare le proprie strutture dati nel disco, cosa che fa in tre passi.

Il primo passo è quello di suddividere il dispositivo in uno o più gruppi di blocchi o pagine, dette partizioni.
Il secondo passo è la creazione e la gestione del volume.
Il terzo passo è la formattazione logica, cioè la creazione di un file system: il sistema operativo registra nel dispositivo le strutture dati iniziali relative al file system.

Le informazioni sulle partizioni indicano anche se una partizione contiene un file system avviabile (contenente il sistema operativo). La partizione etichettata per l’avvio viene utilizzata per stabilire la radice (root) del file system; una volta montata questa partizione è possibile creare collegamenti per tutti gli altri dispositivi e le relative partizioni. In generale, il “file system” di un computer è costituito da tutti i volumi montati. Su Windows, questi vengono denominati separatamente tramite una lettera (C:, D:, E:), mentre su altri sistemi, come Linux, al momento dell’avvio viene montato il file system principale e gli altri file system possono essere montati all’interno della stessa struttura ad albero.
In Windows l’interfaccia del file system rende chiaro quando viene utilizzato un determinato dispositivo, mentre in Linux un singolo accesso a un file può passare per l’attraversamento di molti dispositivi prima di arrivare al file system che lo contiene (all’interno di un volume).

Per una maggior efficienza, la maggior parte dei file system accorpa i blocchi in gruppi, detti cluster. L’i/o del dispositivo procede per blocchi, ma l’i/o del file system procede invece per cluster, di modo che l’i/o abbia caratteristiche di accesso più sequenziale che casuale. I file system cercano anche di collocare il contenuto del file vicino ai suoi metadati, riducendo così i tempi di ricerca in un hdd quando si opera su un file.

Alcuni sistemi operativi dànno l’opportunità a certi programmi speciali di impiegare una partizione del disco come un grande array sequenziale di blocchi logici, non contenente alcuna struttura dati relativa al file system.
Questo array è detto a volte disco di basso livello (_raw disk_); l’i/o relativo si chiama i/o di basso livello (_raw_ _i/o_). Un sistema di questo tipo può essere utilizzato come spazio di swap (si veda il Paragrafo 11.6.2), per esempio; inoltre, alcuni sistemi per la gestione di basi di dati preferiscono questo tipo di i/o perché permette di controllare l’esatta posizione nel disco di ogni record. Il raw i/o bypassa tutti i servizi del file system: gestione delle _buffer cache_, locking dei file, prefetching, l’allocazione dello spazio, la gestione dei i nomi dei file e le directory. È possibile rendere certe applicazioni più efficienti permettendogli di implementare servizi di memorizzazione specializzati che usino una partizione di basso livello, ma la maggior parte delle applicazioni preferisce un file system già fornito piuttosto che prendersi carico della gestione dei dati. Si noti che Linux in generale non supporta l’i/o di basso livello, tuttavia è possibile ottenere un accesso di questo tipo utilizzando il flag direct nella chiamata di sistema open().