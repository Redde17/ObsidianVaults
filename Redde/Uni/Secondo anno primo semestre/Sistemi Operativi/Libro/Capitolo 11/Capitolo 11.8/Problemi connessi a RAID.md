I sistemi raid, purtroppo, non assicurano sempre la disponibilità dei dati al sistema operativo e agli utenti. 
Un puntatore a un file potrebbe essere errato, per esempio, e lo stesso potrebbe accadere ai puntatori nella struttura interna dei file.
Le operazioni incomplete di scrittura, se non ripristinate in maniera adeguata, possono alterare i dati. Altri processi, inoltre, potrebbero scrivere accidentalmente sulle strutture del file system. raid protegge dagli errori derivanti dai supporti fisici per la memorizzazione, ma non da altri tipi di errori dovuti all’hardware e ai programmi. 
I pericoli potenziali, per i dati di un sistema, si estendono alla totalità degli errori derivanti dal software e dall’hardware.

Per risolvere tali problemi, il file system Solaris zfs ricorre a una strategia innovativa per verificare l’integrità dei dati. 
Esso applica una checksum (_somma di controllo_) interna a ogni blocco, dati e metadati inclusi. Le checksum non risiedono nel blocco sottoposto a controllo: ciascuna di esse, invece, è memorizzata insieme al puntatore a quel blocco.
![[Pasted image 20221216193425.png]]
Si consideri un inode – una struttura dati per memorizzare i metadati del file system - con puntatori ai propri dati. 
All’interno dell’inode si trova la checksum per ciascun blocco di dati. Se si verifica un problema con i dati, la checksum darà un valore errato e il file system verrà a conoscenza del problema. Qualora sia attivo il mirroring, il sistema zfs, in presenza di un blocco con una checksum corretta e di uno con una checksum errata, sostituirà automaticamente il blocco errato con quello valido. 
In maniera simile, l’elemento della directory che punta all’inode possiede una checksum relativa all’inode. Qualunque problema riguardi l’inode, quindi, è rilevato al momento dell’accesso alla directory. Queste checksum, che sono applicate a tutte le strutture di zfs, producono risultati molto più efficaci degli ambienti raid o dei file system tradizionali, per livello di coerenza, rilevazione degli errori e capacità di correggerli. 
Il sovraccarico di gestione determinato dal calcolo delle checksum e dai cicli supplementari di lettura-modifica-scrittura dei blocchi non condizionano il funzionamento complessivo di zfs, che mantiene un’alta velocità nelle prestazioni. 
Una funzionalità di checksum simile è presente nel file system btrfs di Linux

Un altro problema della maggior parte delle implementazioni raid è la mancanza di flessibilità. Considerate un array di memorizzazione dotato di venti unità divise in quattro insiemi da cinque unità. Ogni gruppo di cinque unità è un insieme raid di livello 5. Ne risultano quattro volumi separati, ciascuno contenente un proprio file system. Ma che cosa succede se un file system ha una dimensione troppo grande per un insieme raid di livello 5 a cinque unità? E se un altro file system necessita di un’area molto ridotta? Se tali fattori sono noti in anticipo, allora i dischi e i volumi possono essere allocati adeguatamente. Frequentemente, però, l’utilizzo delle unità e le richieste variano nel tempo.

Anche se l’array di memorizzazione ha permesso all’intero insieme di venti unità di essere creato come un grande insieme raid, potrebbero insorgere altre problematiche. Nell’insieme potrebbero essere costruiti diversi volumi di dimensioni differenti. Alcuni gestori del volume non ci permettono però di cambiare la dimensione di un volume. In quel caso si ripresenterebbe la stessa situazione descritta in precedenza, ovvero dimensioni non adatte al file system. Alcuni gestori di volume permettono cambiamenti di dimensione, ma alcuni file system non permettono l’aumento o la diminuzione della dimensione del file system stesso. I volumi potrebbero cambiare dimensione, ma i file system dovrebbero essere ricreati per poter usufruire di quei cambiamenti.

zfs combina la gestione dei file system e quella dei volumi in una unità in grado di offrire una maggiore funzionalità rispetto a quella permessa dalla tradizionale separazione di tali funzioni. 
I dischi, o le partizioni di dischi, sono riuniti in gruppi di memorizzazione (_pools of storage_) attraverso insiemi raid.
Un gruppo o pool può contenere uno o più file system zfs. Tutta l’area libera di un pool è a disposizione di tutti i file system contenuti all’interno di quel pool. zfs utilizza il modello di gestione della memoria basato su malloc() e free() per allocare e rilasciare memoria nei file system quando i blocchi vengono utilizzati e liberati all’interno del file system. 
Di conseguenza non ci sono limiti artificiali all’utilizzo della memoria e non sussiste la necessità di ridistribuire i file system tra i volumi né di ridimensionare i volumi. zfs stabilisce delle quote per limitare la dimensione di un file system e definisce dei meccanismi di prenotazione per assicurarsi che il file system possa aumentare all’interno di una dimensione specificata, ma queste variabili possono essere sempre cambiate dal proprietario del file system.
Altri sistemi, come Linux, hanno gestori di volumi che consentono l’unione logica di più dischi per creare volumi più grandi dei dischi stessi, in modo da poter contenere file system di grandi dimensioni.
La Figura 11.18(a) illustra i volumi e i file system tradizionali, mentre la Figura 11.18(b) rappresenta il modello zfs.
![[Pasted image 20221216194105.png]]
