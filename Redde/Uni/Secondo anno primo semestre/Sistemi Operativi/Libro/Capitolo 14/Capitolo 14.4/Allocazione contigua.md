Per usare il metodo di allocazione contigua, ogni file deve occupare un insieme di blocchi contigui del disco. Gli indirizzi del disco definiscono un ordinamento lineare nel disco stesso. Con questo ordinamento, supponendo che un unico job stia accedendo al disco, l’accesso al blocco _b_ + 1 dopo il blocco _b_ non richiede normalmente alcuno spostamento della testina. Se la testina deve essere spostata (dall’ultimo settore di un cilindro al primo settore del cilindro successivo) lo spostamento è di una sola traccia. Quindi, il numero dei posizionamenti (_seek_) richiesti per accedere a file il cui spazio è allocato in modo contiguo è minimo, così com’è trascurabile il tempo di ricerca (_seek time_), quando quest’ultimo è necessario.

L’allocazione contigua dello spazio per un file è definita dall’indirizzo del primo blocco e dalla lunghezza (espressa in numero di blocchi). Se il file è lungo _n_ blocchi e comincia dalla locazione _b_, allora occupa i blocchi _b_, _b_ + 1, _b_ + 2, ..., _b_ + _n_ – 1. L’elemento di directory per ciascun file indica l’indirizzo del blocco d’inizio e la lunghezza dell’area assegnata per questo file.
![[Pasted image 20221220140755.png]]

Accedere a un file il cui spazio è assegnato in modo contiguo è facile. Quando si usa un accesso sequenziale, il file system memorizza l’indirizzo dell’ultimo blocco cui è stato fatto riferimento e, se è necessario, legge il blocco successivo. Nel caso di un accesso diretto al blocco _i_ di un file che comincia al blocco _b_ si può accedere immediatamente al blocco _b_ + _i_.
Quindi, sia l’accesso sequenziale sia quello diretto si possono gestire con l’allocazione contigua.

L’allocazione contigua presenta però alcuni problemi. Una difficoltà riguarda l’individuazione dello spazio per un nuovo file.

Il problema dell’allocazione contigua dello spazio dei dischi si può considerare un’applicazione particolare del problema generale dell’allocazione dinamica della memoria, trattato nel Paragrafo 9.2; il problema generale è, infatti, quello di soddisfare una richiesta di dimensione _n_ data una lista di buchi liberi. I più comuni criteri di scelta di un buco libero da un insieme di buchi disponibili sono _first-fit_ e _best-fit_. Simulazioni hanno dimostrato che questi due criteri sono più efficienti del _worst-fit_ sia in termini di tempo sia d’uso della memoria. Nessuno dei due è chiaramente migliore dell’altro rispetto all’uso della memoria, ma _first-fit_ è generalmente più rapido.

Questi algoritmi soffrono della frammentazione esterna: assegnando e liberando lo spazio per i file, lo spazio libero dei dischi viene frammentato in tanti piccoli pezzi. La frammentazione esterna si ha ogniqualvolta lo spazio libero è suddiviso in pezzi, e diviene un problema quando il più grande di tali pezzi contigui non è sufficiente a soddisfare una richiesta; la memoria viene frammentata in tanti buchi, nessuno dei quali è abbastanza grande da contenere i dati. A seconda della capacità dei dischi e della dimensione media dei file, la frammentazione esterna può essere un problema più o meno grave.

Una strategia per prevenire la perdita di una quantità significativa di spazio sul disco a causa della frammentazione esterna consiste nel copiare un intero file system su un altro disco. Così si libera completamente il primo disco creando un ampio spazio libero contiguo; poi si copiano nuovamente i file nel primo disco, assegnando spazio contiguo da questa ampia zona libera. Questo schema compatta efficacemente tutto lo spazio libero in uno spazio contiguo, risolvendo il problema della frammentazione. Il costo di questa compattazione è rappresentato dal tempo necessario, ed è particolarmente alto per i dischi di grande capacità; per essi, compattare lo spazio può richiedere ore e può essere necessario eseguire tale operazione settimanalmente. Alcuni sistemi richiedono l’esecuzione non in linea (_off-line_) di questa funzionalità, ossia con il file system non montato. Durante questo periodo di indisponibilità (_down time_) il normale funzionamento del sistema non è in genere possibile, quindi tale compattazione viene evitata a tutti i costi per i calcolatori operativi. La maggior parte dei sistemi moderni è invece in grado di eseguire la deframmentazione in linea (_on-line_), ossia durante il loro normale funzionamento, a prezzo, però, di una notevole diminuzione delle prestazioni.

Un altro problema che riguarda l’allocazione contigua è la determinazione della quantità di spazio necessaria per un file. Quando si crea un file, occorre trovare e allocare lo spazio di cui necessita. Come può il programma o la persona che lo crea conoscere la dimensione del file da creare? In alcuni casi questa dimensione si può stabilire in modo abbastanza semplice, per esempio quando si copia un file esistente; in generale, tuttavia, non è facile stimare la dimensione di un file che deve contenere dati prodotti da un programma.

Se un file riceve poco spazio, può essere impossibile estenderlo: soprattutto nel caso in cui si adoperi il criterio di allocazione _best-fit_, lo spazio alle due estremità del file può essere già in uso, quindi non è possibile ampliare il file in modo contiguo. Esistono allora due possibilità. La prima è terminare il programma utente con un idoneo messaggio d’errore. L’utente deve allora allocare più spazio ed eseguire di nuovo il programma. Queste esecuzioni ripetute possono essere onerose; per prevenire tale circostanza, normalmente l’utente sovrastima la quantità di spazio necessaria, sprecandone parecchio. L’altra possibilità consiste nel trovare un buco più grande, copiare il contenuto del file nel nuovo spazio e rilasciare lo spazio precedente. Queste operazioni si possono ripetere finché esiste spazio, anche se ciò può far perdere tempo. In questo caso tuttavia non è necessario informare esplicitamente l’utente su che cosa stia succedendo; anche se sempre più lentamente, il sistema prosegue le attività nonostante il problema.

Anche se si conosce in anticipo la quantità di spazio necessaria per un file, l’allocazione preventiva può in ogni modo essere inefficiente. A un file che cresce lentamente in un periodo di tempo lungo (mesi o anni) si deve allocare spazio sufficiente per la sua dimensione finale, anche se molto di quello spazio può rimanere inutilizzato per parecchio tempo. Il file ha perciò una grande frammentazione interna.

Per ridurre al minimo questi inconvenienti, alcuni sistemi operativi fanno uso di uno schema di allocazione contigua modificato: inizialmente si assegna una porzione di spazio contiguo, e se questa non è abbastanza grande si aggiunge un’altra porzione di spazio contiguo, detta estensione. Allora la locazione dei blocchi dei file si registra come una locazione e un numero dei blocchi, insieme con l’indirizzo del primo blocco della prossima estensione. In alcuni sistemi il proprietario del file può impostare la dimensione dell’estensione, ma tale possibilità, se l’indicazione è imprecisa, può causare inefficienze. La frammentazione interna può ancora essere un problema se le estensioni sono troppo grandi; si possono presentare problemi dovuti alla frammentazione esterna quando si assegnano e si rilasciano estensioni di dimensione variabile.