L’allocazione concatenata risolve tutti i problemi dell’allocazione contigua. Con questo tipo di allocazione, infatti, ogni file è composto da una lista concatenata di blocchi del disco i quali possono essere sparsi in qualsiasi punto del disco stesso. La directory contiene un puntatore al primo e all’ultimo blocco del file. Per esempio, un file di cinque blocchi può cominciare dal blocco 9, continuare al blocco 16, quindi al blocco 1, al blocco 10 e infine terminare al blocco 25.
Ogni blocco contiene un puntatore al blocco successivo. Questi puntatori non sono disponibili all’utente, quindi se ogni blocco è formato di 512 byte e un indirizzo del disco (il puntatore) richiede 4 byte, l’utente vede blocchi di 508 byte.
![[Pasted image 20221220141509.png]]

Per creare un nuovo file si crea semplicemente un nuovo elemento nella directory. 
Con l’allocazione concatenata, ogni elemento della directory ha un puntatore al primo blocco del file. 
Questo puntatore s’inizializza a null (valore del puntatore di fine lista) a indicare un file vuoto; anche il campo della dimensione s’imposta a 0. 
Un’operazione di scrittura nel file determina la ricerca di un blocco libero attraverso il sistema di gestione dello spazio libero, la scrittura in tale blocco, e la concatenazione di tale blocco alla fine del file. 
Per leggere un file occorre semplicemente leggere i blocchi seguendo i puntatori da un blocco all’altro. 
Con l’allocazione concatenata non esiste frammentazione esterna e per soddisfare una richiesta si può usare qualsiasi blocco libero della lista. Inoltre non è necessario dichiarare la dimensione di un file al momento della sua creazione. Un file può continuare a crescere finché sono disponibili blocchi liberi, di conseguenza non è mai necessario compattare lo spazio del disco.

L’allocazione concatenata presenta comunque alcuni svantaggi. 
Il problema principale riguarda il fatto che può essere usata in modo efficiente solo per i file ad accesso sequenziale. 
Per trovare l’_i_-esimo blocco di un file occorre partire dall’inizio del file e seguire i puntatori finché non si raggiunge l’_i_-esimo blocco. Ogni accesso a un puntatore implica una lettura del disco, e talvolta un posizionamento della testina. Di conseguenza, per file il cui spazio è assegnato in modo concatenato, la funzione d’accesso diretto è inefficiente.

Un altro svantaggio dell’allocazione concatenata riguarda lo spazio richiesto per i puntatori. Se un puntatore richiede 4 byte di un blocco di 512 byte, allora lo 0,78 per cento del disco è usato per i puntatori anziché per le informazioni: ogni file richiede un po’ più spazio di quanto ne richiederebbe altrimenti.

La soluzione più comune a questo problema consiste nel riunire un certo numero di blocchi contigui in cluster (gruppi di blocchi), e nell’allocare i cluster anziché i blocchi. Per esempio, il file system può definire cluster di 4 blocchi e operare nel disco soltanto per unità di cluster. Così i puntatori usano una percentuale molto più piccola dello spazio del disco. Questo metodo permette che la corrispondenza tra blocchi logici e blocchi fisici rimanga semplice, ma migliora il throughput del disco poiché si hanno meno posizionamenti della testina, inoltre diminuisce lo spazio necessario per l’allocazione dei blocchi e la gestione della lista dei blocchi liberi. Il costo di questo metodo è dato da un incremento della frammentazione interna, poiché se un cluster è parzialmente pieno si spreca più spazio di quanto se ne sprecherebbe con un solo blocco parzialmente pieno. I cluster si possono usare per ottimizzare l’accesso ai dischi in molti altri algoritmi, quindi s’impiegano nella maggior parte dei file system.

Un altro problema dell’allocazione concatenata riguarda l’affidabilità. Poiché i file sono tenuti insieme da puntatori sparsi per tutto il disco, s’immagini che cosa accadrebbe se un puntatore andasse perduto o danneggiato. Un errore di programmazione del sistema operativo oppure un errore hardware di un’unità a disco potrebbero causare la lettura di un puntatore errato. Questo errore, a sua volta, potrebbe causare il collegamento alla lista dei blocchi liberi oppure a un altro file. Una soluzione parziale a tale problema consiste nell’usare liste doppiamente concatenate oppure nel memorizzare il nome del file e il relativo numero di blocco in ogni blocco; questi schemi però richiedono un overhead ancora maggiore per ogni file.

Una variante importante del metodo di allocazione concatenata consiste nell’uso della tabella di allocazione dei file (_file allocation table_, fat). 
Tale metodo di allocazione dello spazio dei dischi, semplice ma efficiente, era usato nei sistemi operativi ms-dos. Per contenere tale tabella si riserva una sezione del disco all’inizio di ciascun volume; la fat ha un elemento per ogni blocco del disco ed è indicizzata dal numero di blocco; si usa essenzialmente come una lista concatenata.
L’elemento di directory contiene il numero del primo blocco del file. L’elemento della tabella indicizzato da quel numero di blocco contiene a sua volta il numero del blocco successivo del file. 
Questa catena continua fino all’ultimo blocco, che ha come elemento della tabella un valore speciale di fine del file. I blocchi inutilizzati sono indicati nella tabella da un valore 0. L’allocazione di un nuovo blocco a un file richiede semplicemente la localizzazione del primo elemento della tabella con valore 0 e la sostituzione del valore di fine del file precedente con l’indirizzo del nuovo blocco; lo 0 è quindi sostituito con il valore di fine del file. Un esempio esplicativo di tale metodo è dato dalla struttura della fat della Figura 14.6, per un file formato dai blocchi 217, 618 e 339.
![[Pasted image 20221220142149.png]]

Lo schema di allocazione basato sulla fat, se non si usa una cache, può causare un significativo numero di posizionamenti della testina. La testina del disco deve spostarsi all’inizio del volume per leggere la fat e trovare la locazione del blocco in questione, quindi raggiungere la locazione del blocco stesso; nel caso peggiore sono necessari ambedue i movimenti per ciascun blocco. 
Un vantaggio è dato dall’ottimizzazione del tempo d’accesso diretto, poiché la testina del disco può trovare la locazione di ogni blocco leggendo le informazioni contenute nella fat.